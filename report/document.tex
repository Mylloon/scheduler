\DocumentMetadata{testphase = {phase-II,sec,toc,graphic,minipage,float,text}}
\documentclass{article}

\usepackage[T1]{fontenc} % encoding
\renewcommand{\familydefault}{\sfdefault} % sans-serif font

% Langages
\usepackage[french]{babel}
\frenchsetup{SmallCapsFigTabCaptions=false}

% Add \extra info to title
\makeatletter
\providecommand{\extra}[1]{
  \apptocmd{\@author}{
    \end{tabular}
    \par\vspace*{0.7em}
    \begin{tabular}[t]{c}
    #1}{}{}
}
\makeatother

% Code integration
\usepackage{minted}
\setminted[c]{autogobble,frame=lines}
\usemintedstyle{emacs}

\def\titleName{Projet : Un ordonnanceur par work stealing}
\def\docTitle{\href{https://www.irif.fr/~jch/enseignement/systeme/projet.pdf}{\titleName}}

\def\anri{Anri Kennel}
\def\authorMail{mailto:anri.kennel@etu.u-paris.fr}
\def\docSubject{Programmation système avancée}
\def\docLocation{Université Paris Cité}

\usepackage[
  pdfauthor={\anri},        % author  metadata
  pdftitle={\titleName},    % title   metadata
  pdfsubject={\docSubject}, % subject metadata
  hidelinks,                % clickable links in table of contents
]{hyperref}

\title{\docTitle}
\author{\href{\authorMail}{\anri}\thanks{\anri : 22302653}}
\extra{\docSubject~$\cdot$ \docLocation}
\date{Année universitaire 2023-2024}

\newcommand{\docref}[1]{\textit{\nameref{#1}}} % italic nameref

% Aliases
\def\coeurs{c\oe{}urs}


\begin{document}
\maketitle
\flushbottom
\tableofcontents
\clearpage

\section{Descriptions}
Description des différents algorithmes implémentés.

\subsection{Naïf}
Cette implémentation naïve est celle fourni dans le fichier
\texttt{quicksort.c} avec le mode \texttt{serial}.

\subsection[Threads sans gestion]{%
  Threads\footnote{processus léger} sans gestion}
Cette implémentation correspond à simplement démarrer un nouveau thread
pour chaque nouvelle tâche.

\subsection{Threads avec pile}\label{desc:th_pile}
Pour cette implémentation, on garde en mémoire une pile,
et on démarre un nombre fixe de threads et à chaque ajout d'une tâche,
on l'empile. Chaque thread récupère la dernière tâche ajoutée à la pile.

\subsubsection{Sélection aléatoire de tâche}
Même fonctionnement que dans l'algorithme de \docref{desc:th_pile}, sauf
qu'au lieu de récupérer la dernière tâche, on récupère une tâche
aléatoire de la pile.

\subsection{Répartition par \coeurs}
\dots

\section{Statistiques}
Chaque implémentation a été testée avec l'optimisation de niveau 2
de \texttt{gcc}, parfois sur 2 machines. %TODO:parfois?

\def\mone{\textit{Machine 1}} % fixe
\def\mtwo{\textit{Machine 2}} % portable

\begin{enumerate}
  \item \textbf{12 \coeurs} pour la \mone.
  \item \textbf{8 \coeurs} pour la \mtwo.
\end{enumerate}

\subsection{Naïf}\label{stats:naive}
\begin{description}
  \item[\mone] Le programme a été lancé \textbf{100 fois}.
        Le temps moyen d'exécution a été de \textbf{0,855 secs}
  \item[\mtwo] Le programme a été lancé \textbf{\dots fois}.
        Le temps moyen d'exécution a été de \textbf{\dots secs}
\end{description}

Ce programme ne bénéficie pas de toute la puissance de la machine.

\subsection{Threads sans gestion}\label{stats:th_ges}
\begin{description}
  \item[\mone] Le programme a été lancé \textbf{10 fois}.
        Le temps moyen d'exécution a été de \textbf{35,985 secs}
  \item[\mtwo] Le programme a été lancé \textbf{\dots fois}.
        Le temps moyen d'exécution a été de \textbf{\dots secs}
\end{description}

La création des threads pour chaque tâche créer un énorme
goulot d'étranglement qui réduit de grandement les performances.

\subsection{Threads avec pile}
\begin{description}
  \item[\mone] Le programme a été lancé \textbf{100 fois}.
        Le temps moyen d'exécution a été de \textbf{0,258 secs}
  \item[\mtwo] Le programme a été lancé \textbf{\dots fois}.
        Le temps moyen d'exécution a été de \textbf{\dots secs}
\end{description}

Le lancement de nouveau thread étant limité par machine, les performances
sont grandement améliorées par rapport aux tests de \docref{stats:th_ges}.

Également grâce au fait que désormais on utilise les \coeurs~de notre CPU,
les performances sont aussi améliorées par rapport aux tests de
\docref{stats:naive}.

\subsubsection{Sélection aléatoire de tâche}
\begin{description}
  \item[\mone] Le programme a été lancé \textbf{100 fois}.
        Le temps moyen d'exécution a été de \textbf{0,390 secs}
  \item[\mtwo] Le programme a été lancé \textbf{\dots fois}.
        Le temps moyen d'exécution a été de \textbf{\dots secs}
\end{description}

\dots

\subsection{Répartition par \coeurs}
\begin{description}
  \item[\mone] Le programme a été lancé \textbf{100 fois}.
        Le temps moyen d'exécution a été de \textbf{0,19562721 secs}
  \item[\mtwo] Le programme a été lancé \textbf{\dots fois}.
        Le temps moyen d'exécution a été de \textbf{\dots secs}
\end{description}

\dots

\end{document}
